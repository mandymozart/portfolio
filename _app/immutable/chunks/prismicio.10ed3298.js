import"./index.4c6eb505.js";import"./paths.bda8d1ab.js";import{a as $}from"./index.5d05cbe9.js";const I=s=>Array.isArray(s)?`[${s.map(I).join(", ")}]`:typeof s=="string"?`"${s}"`:s instanceof Date?`${s.getTime()}`:`${s}`,h=s=>(t,...r)=>{const i=r.map(I).join(", "),o=t&&r.length?", ":"";return`[${s}(${t}${o}${i})]`},A=s=>{const e=h(s);return r=>e(r)},M=s=>{const e=h(s);return(...r)=>e("",...r)},y={at:h("at"),not:h("not"),any:h("any"),in:h("in"),fulltext:h("fulltext"),has:A("has"),missing:A("missing"),similar:M("similar"),geopointNear:h("geopoint.near"),numberLessThan:h("number.lt"),numberGreaterThan:h("number.gt"),numberInRange:h("number.inRange"),dateAfter:h("date.after"),dateBefore:h("date.before"),dateBetween:h("date.between"),dateDayOfMonth:h("date.day-of-month"),dateDayOfMonthAfter:h("date.day-of-month-after"),dateDayOfMonthBefore:h("date.day-of-month-before"),dateDayOfWeek:h("date.day-of-week"),dateDayOfWeekAfter:h("date.day-of-week-after"),dateDayOfWeekBefore:h("date.day-of-week-before"),dateMonth:h("date.month"),dateMonthAfter:h("date.month-after"),dateMonthBefore:h("date.month-before"),dateYear:h("date.year"),dateHour:h("date.hour"),dateHourAfter:h("date.hour-after"),dateHourBefore:h("date.hour-before")},p=s=>Array.isArray(s)?s:[s],f=(s={},e)=>({...s,filters:[...s.filters||[],...p(e)]}),C=s=>typeof s=="function"?s:()=>s,F=s=>y.at("document.tags",p(s));var O=Object.defineProperty,U=(s,e,t)=>e in s?O(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,_=(s,e,t)=>(U(s,typeof e!="symbol"?e+"":e,t),t);class g extends Error{constructor(e="An invalid API response was returned",t,r){super(e),_(this,"url"),_(this,"response"),this.url=t,this.response=r}}const k=(s,e)=>{const t=s.find(r=>e(r));if(!t)throw new g("Ref could not be found.",void 0,void 0);return t},L=s=>k(s,e=>e.isMasterRef),S=(s,e)=>k(s,t=>t.id===e),P=(s,e)=>k(s,t=>t.label===e),D="io.prismic.preview",E=s=>s.replace(/%3B/g,";"),x=s=>{const e=s.split("; ");let t;for(const r of e){const i=r.split("=");if(E(i[0]).replace(/%3D/g,"=")===D){t=E(i.slice(1).join("="));break}}return t},N=s=>s.replace(/(\n| )*( |{|})(\n| )*/gm,(e,t,r)=>r),b=s=>y.any("document.tags",p(s)),m=s=>y.at("document.type",s);class v extends g{}class T extends g{}class z extends g{}class J extends v{}class G extends v{}class Q extends v{}class H extends T{}const V={accessToken:"access_token"},Y=s=>typeof s=="string"?s:s.direction==="desc"?`${s.field} desc`:s.field,Z=(s,e)=>{const{filters:t,predicates:r,...i}=e,o=new URL("documents/search",`${s}/`);if(t)for(const n of p(t))o.searchParams.append("q",`[${n}]`);if(r)for(const n of p(r))o.searchParams.append("q",`[${n}]`);for(const n in i){const a=V[n]||n;let l=i[n];if(a==="orderings"){const c=i[a];c!=null&&(l=`[${p(c).map(w=>Y(w)).join(",")}]`)}else a==="routes"&&typeof i[a]=="object"&&(l=JSON.stringify(p(i[a])));l!=null&&o.searchParams.set(a,p(l).join(","))}return o.toString()},W=s=>/^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(s),X=s=>{if(W(s))return`https://${s}.cdn.prismic.io/api/v2`;throw new g(`An invalid Prismic repository name was given: ${s}`,void 0,void 0)},K=s=>{try{return new URL(s),!0}catch{return!1}};var ee=Object.defineProperty,te=(s,e,t)=>e in s?ee(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,u=(s,e,t)=>(te(s,typeof e!="symbol"?e+"":e,t),t);const se=100,re=5e3,ie=500,ne=1e3;var d;(function(s){s.Master="Master",s.ReleaseID="ReleaseID",s.ReleaseLabel="ReleaseLabel",s.Manual="Manual"})(d||(d={}));const ae=(s,e)=>new oe(s,e);class oe{constructor(e,t={}){if(u(this,"endpoint"),u(this,"accessToken"),u(this,"routes"),u(this,"brokenRoute"),u(this,"fetchFn"),u(this,"fetchOptions"),u(this,"defaultParams"),u(this,"refState",{mode:d.Master,autoPreviewsEnabled:!0}),u(this,"cachedRepository"),u(this,"cachedRepositoryExpiration",0),u(this,"fetchJobs",{}),K(e)?this.endpoint=e:this.endpoint=X(e),this.accessToken=t.accessToken,this.routes=t.routes,this.brokenRoute=t.brokenRoute,this.fetchOptions=t.fetchOptions,this.defaultParams=t.defaultParams,t.ref&&this.queryContentFromRef(t.ref),typeof t.fetch=="function")this.fetchFn=t.fetch;else if(typeof globalThis.fetch=="function")this.fetchFn=globalThis.fetch;else throw new g("A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.",void 0,void 0);this.fetchFn===globalThis.fetch&&(this.fetchFn=this.fetchFn.bind(globalThis)),this.graphQLFetch=this.graphQLFetch.bind(this)}enableAutoPreviews(){this.refState.autoPreviewsEnabled=!0}enableAutoPreviewsFromReq(e){this.refState.httpRequest=e,this.refState.autoPreviewsEnabled=!0}disableAutoPreviews(){this.refState.autoPreviewsEnabled=!1}async get(e){const t=await this.buildQueryURL(e);return await this.fetch(t,e)}async getFirst(e){var t;const r={...e};!(e&&e.page)&&!(e!=null&&e.pageSize)&&(r.pageSize=((t=this.defaultParams)==null?void 0:t.pageSize)??1);const i=await this.buildQueryURL(r),n=(await this.fetch(i,e)).results[0];if(n)return n;throw new T("No documents were returned",i,void 0)}async dangerouslyGetAll(e={}){var t;const{limit:r=1/0,...i}=e,o={...i,pageSize:Math.min(r,i.pageSize||((t=this.defaultParams)==null?void 0:t.pageSize)||se)},n=[];let a;for(;(!a||a.next_page)&&n.length<r;){const l=a?a.page+1:void 0;a=await this.get({...o,page:l}),n.push(...a.results),a.next_page&&await new Promise(c=>setTimeout(c,ie))}return n.slice(0,r)}async getByID(e,t){return await this.getFirst(f(t,y.at("document.id",e)))}async getByIDs(e,t){return await this.get(f(t,y.in("document.id",e)))}async getAllByIDs(e,t){return await this.dangerouslyGetAll(f(t,y.in("document.id",e)))}async getByUID(e,t,r){return await this.getFirst(f(r,[m(e),y.at(`my.${e}.uid`,t)]))}async getByUIDs(e,t,r){return await this.get(f(r,[m(e),y.in(`my.${e}.uid`,t)]))}async getAllByUIDs(e,t,r){return await this.dangerouslyGetAll(f(r,[m(e),y.in(`my.${e}.uid`,t)]))}async getSingle(e,t){return await this.getFirst(f(t,m(e)))}async getByType(e,t){return await this.get(f(t,m(e)))}async getAllByType(e,t){return await this.dangerouslyGetAll(f(t,m(e)))}async getByTag(e,t){return await this.get(f(t,b(e)))}async getAllByTag(e,t){return await this.dangerouslyGetAll(f(t,b(e)))}async getByEveryTag(e,t){return await this.get(f(t,F(e)))}async getAllByEveryTag(e,t){return await this.dangerouslyGetAll(f(t,F(e)))}async getBySomeTags(e,t){return await this.get(f(t,b(e)))}async getAllBySomeTags(e,t){return await this.dangerouslyGetAll(f(t,b(e)))}async getRepository(e){const t=new URL(this.endpoint);return this.accessToken&&t.searchParams.set("access_token",this.accessToken),await this.fetch(t.toString(),e)}async getRefs(e){return(await this.getRepository(e)).refs}async getRefByID(e,t){const r=await this.getRefs(t);return S(r,e)}async getRefByLabel(e,t){const r=await this.getRefs(t);return P(r,e)}async getMasterRef(e){const t=await this.getRefs(e);return L(t)}async getReleases(e){return(await this.getRefs(e)).filter(r=>!r.isMasterRef)}async getReleaseByID(e,t){const r=await this.getReleases(t);return S(r,e)}async getReleaseByLabel(e,t){const r=await this.getReleases(t);return P(r,e)}async getTags(e){try{const t=await this.getCachedRepositoryForm("tags",e),r=new URL(t.action);return this.accessToken&&r.searchParams.set("access_token",this.accessToken),await this.fetch(r.toString(),e)}catch{return(await this.getRepository(e)).tags}}async buildQueryURL({signal:e,fetchOptions:t,...r}={}){const i=r.ref||await this.getResolvedRefString({signal:e,fetchOptions:t}),o=r.integrationFieldsRef||(await this.getCachedRepository({signal:e,fetchOptions:t})).integrationFieldsRef||void 0;return Z(this.endpoint,{...this.defaultParams,...r,ref:i,integrationFieldsRef:o,routes:r.routes||this.routes,brokenRoute:r.brokenRoute||this.brokenRoute,accessToken:r.accessToken||this.accessToken})}async resolvePreviewURL(e){var t,r;let i=e.documentID,o=e.previewToken;if(typeof globalThis.location<"u"){const n=new URLSearchParams(globalThis.location.search);i=i||n.get("documentId"),o=o||n.get("token")}else if(this.refState.httpRequest){if("query"in this.refState.httpRequest)i=i||((t=this.refState.httpRequest.query)==null?void 0:t.documentId),o=o||((r=this.refState.httpRequest.query)==null?void 0:r.token);else if("url"in this.refState.httpRequest&&this.refState.httpRequest.url){const n=new URL(this.refState.httpRequest.url,"missing-host://").searchParams;i=i||n.get("documentId"),o=o||n.get("token")}}if(i!=null&&o!=null){const n=await this.getByID(i,{ref:o,lang:"*",signal:e.signal,fetchOptions:e.fetchOptions}),a=$(n,{linkResolver:e.linkResolver});if(typeof a=="string")return a}return e.defaultURL}queryLatestContent(){this.refState.mode=d.Master}queryContentFromReleaseByID(e){this.refState={...this.refState,mode:d.ReleaseID,releaseID:e}}queryContentFromReleaseByLabel(e){this.refState={...this.refState,mode:d.ReleaseLabel,releaseLabel:e}}queryContentFromRef(e){this.refState={...this.refState,mode:d.Manual,ref:e}}async graphQLFetch(e,t){const r=await this.getCachedRepository(),i=await this.getResolvedRefString(),o={"Prismic-ref":i,Authorization:this.accessToken?`Token ${this.accessToken}`:"",...t?t.headers:{}};r.integrationFieldsRef&&(o["Prismic-integration-field-ref"]=r.integrationFieldsRef);const n={};for(const c in o)o[c]&&(n[c.toLowerCase()]=o[c]);const a=new URL(e);a.searchParams.set("ref",i);const l=a.searchParams.get("query");return l&&a.searchParams.set("query",N(l)),await this.fetchFn(a.toString(),{...t,headers:n})}async getCachedRepository(e){return(!this.cachedRepository||Date.now()>=this.cachedRepositoryExpiration)&&(this.cachedRepositoryExpiration=Date.now()+re,this.cachedRepository=await this.getRepository(e)),this.cachedRepository}async getCachedRepositoryForm(e,t){const i=(await this.getCachedRepository(t)).forms[e];if(!i)throw new g(`Form with name "${e}" could not be found`,void 0,void 0);return i}async getResolvedRefString(e){var t,r;if(this.refState.autoPreviewsEnabled){let n,a;if((t=this.refState.httpRequest)!=null&&t.headers?"get"in this.refState.httpRequest.headers&&typeof this.refState.httpRequest.headers.get=="function"?a=this.refState.httpRequest.headers.get("cookie"):"cookie"in this.refState.httpRequest.headers&&(a=this.refState.httpRequest.headers.cookie):(r=globalThis.document)!=null&&r.cookie&&(a=globalThis.document.cookie),a&&(n=x(a)),n)return n}const i=await this.getCachedRepository(e),o=this.refState.mode;if(o===d.ReleaseID)return S(i.refs,this.refState.releaseID).ref;if(o===d.ReleaseLabel)return P(i.refs,this.refState.releaseLabel).ref;if(o===d.Manual){const n=await C(this.refState.ref)();if(typeof n=="string")return n}return L(i.refs).ref}async fetch(e,t={}){var r,i,o,n;const a={...this.fetchOptions,...t.fetchOptions,headers:{...(r=this.fetchOptions)==null?void 0:r.headers,...(i=t.fetchOptions)==null?void 0:i.headers},signal:((o=t.fetchOptions)==null?void 0:o.signal)||t.signal||((n=this.fetchOptions)==null?void 0:n.signal)};let l;this.fetchJobs[e]&&this.fetchJobs[e].has(a.signal)?l=this.fetchJobs[e].get(a.signal):(this.fetchJobs[e]=this.fetchJobs[e]||new Map,l=this.fetchFn(e,a).then(async R=>{let w;try{w=await R.json()}catch{}return{status:R.status,headers:R.headers,json:w}}).finally(()=>{this.fetchJobs[e].delete(a.signal),this.fetchJobs[e].size===0&&delete this.fetchJobs[e]}),this.fetchJobs[e].set(a.signal,l));const c=await l;if(c.status!==404&&c.json==null)throw new g(void 0,e,c.json);switch(c.status){case 200:return c.json;case 400:throw new z(c.json.message,e,c.json);case 401:case 403:throw new v(c.json.error||c.json.message,e,c.json);case 404:throw c.json===void 0?new H(`Prismic repository not found. Check that "${this.endpoint}" is pointing to the correct repository.`,e,void 0):c.json.type==="api_notfound_error"?new Q(c.json.message,e,c.json):c.json.type==="api_security_error"&&/preview token.*expired/i.test(c.json.message)?new J(c.json.message,e,c.json):new T(c.json.message,e,c.json);case 410:throw new G(c.json.message,e,c.json);case 429:{const R=Number(c.headers.get("retry-after")),w=Number.isNaN(R)?ne:R;return await new Promise((q,B)=>{setTimeout(async()=>{try{q(await this.fetch(e,t))}catch(j){B(j)}},w)})}}throw new g(void 0,e,c.json)}}const ce=s=>{if(!s.cookies)return;const e=s.cookies.get(D);e&&/\.prismic\.io/.test(e)&&s.client.queryContentFromRef(e)},he="mandymozart-dev",fe="@slicemachine/adapter-sveltekit",le=["./src/lib/slices"],ue="http://localhost:5173/slice-simulator",de={repositoryName:he,adapter:fe,libraries:le,localSliceSimulatorURL:ue},ye={}.VITE_PRISMIC_ENVIRONMENT||de.repositoryName,ge=[{type:"page",uid:"home",path:"/"},{type:"page",path:"/:uid"}],me=({cookies:s,...e}={})=>{const t=ae(ye,{routes:ge,...e});return ce({client:t,cookies:s}),t};export{g as P,me as c,W as i,ye as r};
